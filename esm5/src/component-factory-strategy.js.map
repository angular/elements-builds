{"version":3,"file":"component-factory-strategy.js","sourceRoot":"","sources":["../../../../../packages/elements/src/component-factory-strategy.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,cAAc,EAAoB,wBAAwB,EAA8B,QAAQ,EAAa,YAAY,EAAsB,MAAM,eAAe,CAAC;AAC7K,OAAO,EAAa,KAAK,EAAC,MAAM,MAAM,CAAC;AACvC,OAAO,EAAC,GAAG,EAAC,MAAM,gBAAgB,CAAC;AAGnC,OAAO,EAAC,uBAAuB,EAAC,MAAM,6BAA6B,CAAC;AACpE,OAAO,EAAC,UAAU,EAAE,SAAS,EAAE,YAAY,EAAC,MAAM,SAAS,CAAC;;;;AAG5D,qBAAM,aAAa,GAAG,EAAE,CAAC;;;;;;;AAQzB;;;;;;AAAA;IAGE,2CAAoB,SAAoB,EAAU,QAAkB;QAAhD,cAAS,GAAT,SAAS,CAAW;QAAU,aAAQ,GAAR,QAAQ,CAAU;QAClE,IAAI,CAAC,gBAAgB;YACjB,QAAQ,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;KAC/E;;;;;IAED,kDAAM;;;;IAAN,UAAO,QAAkB;QACvB,MAAM,CAAC,IAAI,0BAA0B,CAAC,IAAI,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;KACxE;4CAnCH;IAoCC,CAAA;;;;;;;AAXD,6CAWC;;;;;;;;;;;;;;;AAQD;;;;;;AAAA;IAyBE,oCAAoB,gBAAuC,EAAU,QAAkB;QAAnE,qBAAgB,GAAhB,gBAAgB,CAAuB;QAAU,aAAQ,GAAR,QAAQ,CAAU;;;;4BAjB5C,IAAI;;;;mCAGjB,KAAK;;;;0CAGqB,IAAI;;;;kCAGZ,IAAI;;;;kCAGd,IAAI,GAAG,EAAe;;;;mCAGrB,IAAI,GAAG,EAAU;KAEmC;IAE3F;;;OAGG;;;;;;;IACH,4CAAO;;;;;;IAAP,UAAQ,OAAoB;;QAE1B,EAAE,CAAC,CAAC,IAAI,CAAC,kBAAkB,KAAK,IAAI,CAAC,CAAC,CAAC;YACrC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;YAC/B,MAAM,CAAC;SACR;QAED,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YACvB,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;SACnC;KACF;IAED;;;OAGG;;;;;;IACH,+CAAU;;;;;IAAV;QAAA,iBAcC;;QAZC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,CAAC,CAAC,CAAC;YAC3D,MAAM,CAAC;SACR;;;QAID,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAC,QAAQ,CAAC;YAC3C,EAAE,CAAC,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC,CAAC;mCACtB,KAAI,CAAC,YAAY,GAAG,OAAO;gBAC3B,KAAI,CAAC,YAAY,GAAG,IAAI,CAAC;aAC1B;SACF,EAAE,aAAa,CAAC,CAAC;KACnB;IAED;;;OAGG;;;;;;;IACH,kDAAa;;;;;;IAAb,UAAc,QAAgB;QAC5B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC9C;QAED,MAAM,CAAC,mBAAC,IAAI,CAAC,YAAY,CAAC,QAAe,EAAC,CAAC,QAAQ,CAAC,CAAC;KACtD;IAED;;;OAGG;;;;;;;;IACH,kDAAa;;;;;;;IAAb,UAAc,QAAgB,EAAE,KAAU;QACxC,EAAE,CAAC,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACtD,MAAM,CAAC;SACR;QAED,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YACvB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAC7C,MAAM,CAAC;SACR;QAED,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QACxC,mBAAC,IAAI,CAAC,YAAY,CAAC,QAAe,EAAC,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;QACtD,IAAI,CAAC,qBAAqB,EAAE,CAAC;KAC9B;IAED;;;OAGG;;;;;;;IACO,wDAAmB;;;;;;IAA7B,UAA8B,OAAoB;QAChD,qBAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,EAAC,SAAS,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,QAAQ,EAAC,CAAC,CAAC;QAC9E,qBAAM,gBAAgB,GAClB,uBAAuB,CAAC,OAAO,EAAE,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;QAC/E,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,aAAa,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;QAE3F,IAAI,CAAC,mBAAmB;YACpB,UAAU,CAAC,oBAAC,IAAI,CAAC,YAAY,CAAC,QAAe,GAAc,CAAC,WAAW,CAAC,CAAC;QAE7E,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEzB,IAAI,CAAC,aAAa,EAAE,CAAC;QAErB,qBAAM,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAiB,cAAc,CAAC,CAAC;QACzE,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;KACvD;IAED,mEAAmE;;;;;IACzD,qDAAgB;;;;IAA1B;QAAA,iBAaC;QAZC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,UAAC,EAAU;gBAAT,sBAAQ;YAC7C,qBAAM,YAAY,GAAG,KAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC3D,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;gBACjB,KAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;aAC5C;YAAC,IAAI,CAAC,CAAC;;;gBAGN,AAFA,kFAAkF;gBAClF,yCAAyC;gBACzC,KAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;aACxC;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;KACjC;IAED,gGAAgG;;;;;IACtF,sDAAiB;;;;IAA3B;QAAA,iBAOC;QANC,qBAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,UAAC,EAAwB;gBAAvB,sBAAQ,EAAE,8BAAY;YAC9E,qBAAM,OAAO,qBAAG,qBAAC,KAAI,CAAC,YAAY,GAAG,QAAQ,EAAQ,CAAC,QAAQ,CAAsB,CAAA,CAAC;YACrF,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,UAAC,KAAU,IAAK,OAAA,CAAC,EAAC,IAAI,EAAE,YAAY,EAAE,KAAK,OAAA,EAAC,CAAC,EAA7B,CAA6B,CAAC,CAAC,CAAC;SACzE,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,GAAG,KAAK,eAAI,aAAa,CAAC,CAAC;KACvC;IAED,mFAAmF;;;;;IACzE,oDAAe;;;;IAAzB;QACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;YAC5D,MAAM,CAAC;SACR;;;QAID,qBAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACvC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QACzB,sBAAC,IAAI,CAAC,YAAY,GAAG,QAAQ,GAAqB,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;KAC9E;IAED;;;OAGG;;;;;;IACO,0DAAqB;;;;;IAA/B;QAAA,iBASC;QARC,EAAE,CAAC,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC,CAAC;YACpC,MAAM,CAAC;SACR;QAED,IAAI,CAAC,0BAA0B,GAAG,SAAS,CAAC,oBAAoB,CAAC;YAC/D,KAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC;YACvC,KAAI,CAAC,aAAa,EAAE,CAAC;SACtB,CAAC,CAAC;KACJ;IAED;;OAEG;;;;;;;IACO,sDAAiB;;;;;;IAA3B,UAA4B,QAAgB,EAAE,YAAiB;;QAE7D,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC;YACnD,MAAM,CAAC;SACR;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC;YAC/B,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;SACxB;;;QAID,qBAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAClB,aAAa,CAAC,YAAY,GAAG,YAAY,CAAC;YAC1C,MAAM,CAAC;SACR;QAED,qBAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC7D,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAE1C,qBAAM,aAAa,GAAG,aAAa,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QAC/E,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,IAAI,YAAY,CAAC,aAAa,EAAE,YAAY,EAAE,aAAa,CAAC,CAAC;KAC5F;IAED,8CAA8C;;;;;IACpC,kDAAa;;;;IAAvB;QACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC;SACR;QAED,IAAI,CAAC,eAAe,EAAE,CAAC;UACvB,IAAI,CAAC,YAAY,GAAG,iBAAiB,CAAC,aAAa;KACpD;qCA3PH;IA4PC,CAAA;;;;;;;AAhND,sCAgNC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, OnChanges, SimpleChange, SimpleChanges, Type} from '@angular/core';\nimport {Observable, merge} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nimport {NgElementStrategy, NgElementStrategyEvent, NgElementStrategyFactory} from './element-strategy';\nimport {extractProjectableNodes} from './extract-projectable-nodes';\nimport {isFunction, scheduler, strictEquals} from './utils';\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n *\n * @experimental\n */\nexport class ComponentNgElementStrategyFactory implements NgElementStrategyFactory {\n  componentFactory: ComponentFactory<any>;\n\n  constructor(private component: Type<any>, private injector: Injector) {\n    this.componentFactory =\n        injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n  }\n\n  create(injector: Injector) {\n    return new ComponentNgElementStrategy(this.componentFactory, injector);\n  }\n}\n\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n *\n * @experimental\n */\nexport class ComponentNgElementStrategy implements NgElementStrategy {\n  /** Merged stream of the component's output events. */\n  events: Observable<NgElementStrategyEvent>;\n\n  /** Reference to the component that was created on connect. */\n  private componentRef: ComponentRef<any>|null;\n\n  /** Changes that have been made to the component ref since the last time onChanges was called. */\n  private inputChanges: SimpleChanges|null = null;\n\n  /** Whether the created component implements the onChanges function. */\n  private implementsOnChanges = false;\n\n  /** Whether a change detection has been scheduled to run on the component. */\n  private scheduledChangeDetectionFn: (() => void)|null = null;\n\n  /** Callback function that when called will cancel a scheduled destruction on the component. */\n  private scheduledDestroyFn: (() => void)|null = null;\n\n  /** Initial input values that were set before the component was created. */\n  private readonly initialInputValues = new Map<string, any>();\n\n  /** Set of inputs that were not initially set when the component was created. */\n  private readonly uninitializedInputs = new Set<string>();\n\n  constructor(private componentFactory: ComponentFactory<any>, private injector: Injector) {}\n\n  /**\n   * Initializes a new component if one has not yet been created and cancels any scheduled\n   * destruction.\n   */\n  connect(element: HTMLElement) {\n    // If the element is marked to be destroyed, cancel the task since the component was reconnected\n    if (this.scheduledDestroyFn !== null) {\n      this.scheduledDestroyFn();\n      this.scheduledDestroyFn = null;\n      return;\n    }\n\n    if (!this.componentRef) {\n      this.initializeComponent(element);\n    }\n  }\n\n  /**\n   * Schedules the component to be destroyed after some small delay in case the element is just\n   * being moved across the DOM.\n   */\n  disconnect() {\n    // Return if there is no componentRef or the component is already scheduled for destruction\n    if (!this.componentRef || this.scheduledDestroyFn !== null) {\n      return;\n    }\n\n    // Schedule the component to be destroyed after a small timeout in case it is being\n    // moved elsewhere in the DOM\n    this.scheduledDestroyFn = scheduler.schedule(() => {\n      if (this.componentRef) {\n        this.componentRef !.destroy();\n        this.componentRef = null;\n      }\n    }, DESTROY_DELAY);\n  }\n\n  /**\n   * Returns the component property value. If the component has not yet been created, the value is\n   * retrieved from the cached initialization values.\n   */\n  getInputValue(property: string): any {\n    if (!this.componentRef) {\n      return this.initialInputValues.get(property);\n    }\n\n    return (this.componentRef.instance as any)[property];\n  }\n\n  /**\n   * Sets the input value for the property. If the component has not yet been created, the value is\n   * cached and set when the component is created.\n   */\n  setInputValue(property: string, value: any): void {\n    if (strictEquals(value, this.getInputValue(property))) {\n      return;\n    }\n\n    if (!this.componentRef) {\n      this.initialInputValues.set(property, value);\n      return;\n    }\n\n    this.recordInputChange(property, value);\n    (this.componentRef.instance as any)[property] = value;\n    this.scheduleDetectChanges();\n  }\n\n  /**\n   * Creates a new component through the component factory with the provided element host and\n   * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n   */\n  protected initializeComponent(element: HTMLElement) {\n    const childInjector = Injector.create({providers: [], parent: this.injector});\n    const projectableNodes =\n        extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n    this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n\n    this.implementsOnChanges =\n        isFunction((this.componentRef.instance as any as OnChanges).ngOnChanges);\n\n    this.initializeInputs();\n    this.initializeOutputs();\n\n    this.detectChanges();\n\n    const applicationRef = this.injector.get<ApplicationRef>(ApplicationRef);\n    applicationRef.attachView(this.componentRef.hostView);\n  }\n\n  /** Set any stored initial inputs on the component's properties. */\n  protected initializeInputs(): void {\n    this.componentFactory.inputs.forEach(({propName}) => {\n      const initialValue = this.initialInputValues.get(propName);\n      if (initialValue) {\n        this.setInputValue(propName, initialValue);\n      } else {\n        // Keep track of inputs that were not initialized in case we need to know this for\n        // calling ngOnChanges with SimpleChanges\n        this.uninitializedInputs.add(propName);\n      }\n    });\n\n    this.initialInputValues.clear();\n  }\n\n  /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n  protected initializeOutputs(): void {\n    const eventEmitters = this.componentFactory.outputs.map(({propName, templateName}) => {\n      const emitter = (this.componentRef !.instance as any)[propName] as EventEmitter<any>;\n      return emitter.pipe(map((value: any) => ({name: templateName, value})));\n    });\n\n    this.events = merge(...eventEmitters);\n  }\n\n  /** Calls ngOnChanges with all the inputs that have changed since the last call. */\n  protected callNgOnChanges(): void {\n    if (!this.implementsOnChanges || this.inputChanges === null) {\n      return;\n    }\n\n    // Cache the changes and set inputChanges to null to capture any changes that might occur\n    // during ngOnChanges.\n    const inputChanges = this.inputChanges;\n    this.inputChanges = null;\n    (this.componentRef !.instance as any as OnChanges).ngOnChanges(inputChanges);\n  }\n\n  /**\n   * Schedules change detection to run on the component.\n   * Ignores subsequent calls if already scheduled.\n   */\n  protected scheduleDetectChanges(): void {\n    if (this.scheduledChangeDetectionFn) {\n      return;\n    }\n\n    this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {\n      this.scheduledChangeDetectionFn = null;\n      this.detectChanges();\n    });\n  }\n\n  /**\n   * Records input changes so that the component receives SimpleChanges in its onChanges function.\n   */\n  protected recordInputChange(property: string, currentValue: any): void {\n    // Do not record the change if the component does not implement `OnChanges`.\n    if (this.componentRef && !this.implementsOnChanges) {\n      return;\n    }\n\n    if (this.inputChanges === null) {\n      this.inputChanges = {};\n    }\n\n    // If there already is a change, modify the current value to match but leave the values for\n    // previousValue and isFirstChange.\n    const pendingChange = this.inputChanges[property];\n    if (pendingChange) {\n      pendingChange.currentValue = currentValue;\n      return;\n    }\n\n    const isFirstChange = this.uninitializedInputs.has(property);\n    this.uninitializedInputs.delete(property);\n\n    const previousValue = isFirstChange ? undefined : this.getInputValue(property);\n    this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);\n  }\n\n  /** Runs change detection on the component. */\n  protected detectChanges(): void {\n    if (!this.componentRef) {\n      return;\n    }\n\n    this.callNgOnChanges();\n    this.componentRef !.changeDetectorRef.detectChanges();\n  }\n}\n"]}